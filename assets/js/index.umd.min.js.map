{"version":3,"file":"index.umd.min.js","sources":["../src/jquery.imageMaps.js"],"sourcesContent":["// The MIT License (MIT)\n\n// Copyright (c) 2016 NAVER Corp.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n/**\n* imageMaps 1.1.0\n* jquery plugin which can be partially linked to the image\n*\n* https://github.com/naver/image-maps\n* demo - https://naver.github.io/image-maps/\n*\n* Released on: July 6, 2016\n* @module imageMaps\n*/\n\nconst shapeFaceClass = '_shape_face';\nconst shapeVertexClass = '_shape_vertex';\nconst areaClass = 'area';\n\n/**\n* @typedef\n* {\"rect\"|\"circle\"|\"ellipse\"|\"text\"|\"image\"|\"poly\"|\"polyline\"|\"polygon\"}\n* module:imageMaps.ShapeType\n*/\n\nconst SHAPE = {\n    RECT: 'rect',\n    CIRCLE: 'circle',\n    ELLIPSE: 'ellipse',\n    TEXT: 'text',\n    IMAGE: 'image',\n    POLY: 'poly',\n    POLYLINE: 'polyline',\n    POLYGON: 'polygon'\n};\n\n/**\n * @see https://api.jquery.com/css/\n * @typedef {PlainObject} module:imageMaps.ShapeStyles\n*/\n\n/**\n* @typedef {PlainObject} module:imageMaps.ImageMapOptions\n* @property {boolean} [isEditMode=false]\n* @property {module:imageMaps.ShapeType} [shape=\"rect\"]\n* @property {string} [shapeText=\"press on link\"]\n* @property {module:imageMaps.ShapeStyles} [shapeStyle] Defaults to\n*   `{fill: '#ffffff', 'fill-opacity': 0.2,\n*     stroke: '#ffffff', 'stroke-width': 3}`\n* @property {function} [onClick=function () {}]\n* @property {function} [onMouseDown=function () {}]\n* @property {function} [onMouseMove=function () {}]\n* @property {function} [onMouseUp=function () {}]\n* @property {function} [onSelect=function () {}]\n*/\n\n/**\n * @type {module:imageMaps.ImageMapOptions}\n */\nconst defaults = {\n    isEditMode: false,\n    // select map area shape type - rect, circle, text, image, poly\n    shape: SHAPE.RECT,\n    shapeText: 'press on link', // shape 옵션이 text일 때 적용된다.\n    shapeStyle: {\n        fill: '#ffffff',\n        'fill-opacity': 0.2,\n        stroke: '#ffffff',\n        'stroke-width': 3\n    },\n    /* eslint-disable no-empty-function */\n    onClick (e, targetAreaHref) {},\n    onMouseDown (e, shapeType, coords) {},\n    onMouseMove (e, shapeType, movedCoords) {},\n    onMouseUp (e, shapeType, updatedCoords) {},\n    onSelect (e, shapeInfo) {}\n    /* eslint-enable no-empty-function */\n};\n\nconst defaultShapeOptions = {\n    // top-left-x, top-left-y, bottom-right-x, botton-right-y\n    rect: [0, 0, 20, 20],\n    circle: [0, 0, 10], // center-x, center-y, radius\n    ellipse: [0, 0, 5, 5], // center-x, center-y, radius-x, radius-y\n    text: [0, 0, 12] // bottom-right-x, bottom-right-y, font-size\n};\n\nconst FONT_SIZE_RATIO = 0.5;\n\nconst NS_SVG = 'http://www.w3.org/2000/svg';\nconst NS_XLINK = 'http://www.w3.org/1999/xlink';\n\n/**\n * Adds {@link external:\"jQuery.fn\"} methods.\n * @function module:imageMaps.jqueryImageMaps\n * @param {external:jQuery} $\n * @returns {external:jQuery}\n */\nfunction jqueryImageMaps ($) {\n    // The actual plugin constructor\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     */\n    class ImageMaps {\n        /**\n         *\n         * @param {external:jQuery} container\n         * @param {module:imageMaps.ImageMapOptions} [options]\n         */\n        constructor (container, options) {\n            this.container = $(container);\n            this.mapEl = null;\n            this.svgEl = null;\n            // merge the default options with user-provided options\n\n            this.options = $.extend(true, {}, defaults, options);\n            this.shapeType = this.options.shape;\n            this.isEditMode = this.options.isEditMode;\n            this.shapeStyle = this.options.shapeStyle;\n            this.shapeText = '';\n            this.shapeImageUrl = '';\n            this.shapeCoords = null;\n            this.vertexCoords = null;\n            this.grabType = null;\n\n            this.containerWidth = 0;\n            this.containerHeight = 0;\n\n            this.touchStartCoords = {\n                x: null, y: null\n            };\n            this.dragInfo = {\n                face: {x: null, y: null},\n                vertex: {x: null, y: null}\n            };\n\n            this.shapeLimitCoords = {\n                x: 30,\n                y: 30,\n                radius: 15\n            };\n\n            this.allShapeInfo = {};\n        }\n\n        /**\n         * ImageMaps: 이미지 엘리먼트 하단에 map, area 엘리먼트 생성 및 속성 부여.\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @returns {void}\n         */\n        createMaps (coords, linkUrl) {\n            const imageWidth = this.container.width();\n\n            if (isNaN(imageWidth) || !imageWidth) {\n                this.container.one(\n                    'load',\n                    $.proxy(createMaps, this, coords, linkUrl)\n                );\n            } else {\n                createMaps.call(this, coords, linkUrl);\n            }\n        }\n\n        /**\n         * @param {module:imageMaps.ShapeType} shapeType\n         * @returns {void}\n         */\n        setShapeType (shapeType) {\n            this.shapeType = shapeType;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {void}\n         */\n        setShapeStyle (styleOptions) {\n            styleOptions = styleOptions || {};\n            this.shapeStyle = $.extend({}, true, this.shapeStyle, styleOptions);\n        }\n\n        /**\n         * @todo Implement\n         * @param {Url} linkUrl\n         * @param {Integer} index\n         * @returns {void}\n         */\n        setUrl (linkUrl, index) { // eslint-disable-line class-methods-use-this\n            // Todo\n        }\n\n        /**\n         *\n         * @param {string} text\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {void}\n         */\n        setTextShape (text, styleOptions) {\n            this.setShapeStyle(styleOptions);\n            this.shapeText = text;\n        }\n\n        /**\n         *\n         * @param {string} imageUrl\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {void}\n         */\n        setImageShape (imageUrl, styleOptions) {\n            this.setShapeStyle(styleOptions);\n            this.shapeImageUrl = imageUrl;\n        }\n\n        /**\n         *\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @param {module:imageMaps.ShapeType} [shapeType]\n         * @returns {void}\n         */\n        addShape (coords, linkUrl, shapeType) {\n            if (shapeType) {\n                this.setShapeType(shapeType);\n            }\n            this.createMaps(coords, linkUrl);\n        }\n\n        /**\n         * @param {Integer} [index]\n         * @returns {void}\n         */\n        removeShape (index) {\n            if (!this.shapeEl) {\n                return;\n            }\n\n            if (typeof index === 'undefined') {\n                index = this.shapeEl.data('index');\n            }\n\n            const areaEl = this.mapEl.find('area[data-index=\"' + index + '\"]');\n            const shapeEl = this.svgEl.find(\n                '.' + shapeFaceClass + '[data-index=\"' + index + '\"]'\n            );\n\n            this.detachEvents(shapeEl, [{\n                type: 'click touchend'\n            }]);\n\n            shapeEl.parent().remove();\n            areaEl.remove();\n\n            this.removeShapeInfo(index);\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        removeAllShapes () {\n            if (!this.shapeEl) {\n                return;\n            }\n\n            const allShapeEls = this.svgEl.find('.' + shapeFaceClass);\n\n            allShapeEls.each((i, shapeEl) => {\n                this.removeShape($(shapeEl).data('index'));\n            });\n\n            this.allShapeInfo = {};\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        removeImageMaps () {\n            this.removeAllShapes();\n            this.svgEl && this.svgEl.remove();\n        }\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.ShapeInfoOptions\n        * @property {Integer} index\n        * @property {module:imageMaps.ShapeCoords} coords\n        * @property {module:imageMaps.ShapeType} type\n        * @property {Url} url\n        * @property {module:imageMaps.ShapeStyles} style\n        */\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.ShapeSecondaryOptions\n        * @property {string} text\n        * @property {HTMLImageElement|string} href\n        */\n\n        /**\n         *\n         * @param {Integer} index\n         * @param {module:imageMaps.ShapeInfoOptions} shapeOptions\n         * @param {\n         *   module:imageMaps.ShapeSecondaryOptions\n         * } [shapeSecondaryOptions]\n         * @returns {void}\n         */\n        updateShapeInfo (index, shapeOptions, shapeSecondaryOptions) {\n            const shapeInfo = this.allShapeInfo;\n\n            shapeOptions.index = index;\n            if (!shapeInfo['shape' + index]) {\n                shapeInfo['shape' + index] = $.extend(\n                    true, shapeOptions, shapeSecondaryOptions\n                );\n            } else {\n                shapeInfo['shape' + index] = $.extend(\n                    true,\n                    {},\n                    shapeInfo['shape' + index],\n                    shapeOptions,\n                    shapeSecondaryOptions\n                );\n            }\n        }\n\n        /**\n         * @param {Integer} index\n         * @returns {void}\n         */\n        removeShapeInfo (index) {\n            delete this.allShapeInfo['shape' + index];\n        }\n\n        /**\n         *\n         * @param {Integer} index\n         * @returns {module:imageMaps.ShapeInfoOptions|\n         *   module:imageMaps.ShapeSecondaryOptions}\n         */\n        getShapeInfo (index) {\n            return this.allShapeInfo['shape' + index];\n        }\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.AllShapeInfo\n        * @property {module:imageMaps.ShapeType} type\n        * @property {module:imageMaps.Coords} coords\n        * @property {Integer} index\n        * @property {module:imageMaps.ShapeInfoOptions|\n        *   module:imageMaps.ShapeSecondaryOptions} shape<num>\n        */\n        /**\n         *\n         * @returns {module:imageMaps.AllShapeInfo}\n         */\n        getAllShapesInfo () {\n            return $.extend(true, {}, this.allShapeInfo);\n        }\n\n        /**\n         *\n         * @param {Float[]} percentages\n         * @returns {void}\n         */\n        zoom (percentages) {\n            zoom.call(this, percentages);\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        enableClick () {\n            this.attachEvents(this.svgEl.find('.' + shapeFaceClass), [{\n                type: 'touchstart', handler: onTouchStart\n            }, {\n                type: 'click touchend', handler: onClickShapeFace\n            }]);\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        disableClick () {\n            this.detachEvents(this.svgEl.find('.' + shapeFaceClass), [{\n                type: 'touchstart', handler: onTouchStart\n            }, {\n                type: 'click touchend', handler: onClickShapeFace\n            }]);\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.ShapeCoords} coords\n         * @returns {void}\n         */\n        setShapeCoords (coords) {\n            this.shapeCoords = coords;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.VertexCoords} coords\n         * @returns {void}\n         */\n        setVertexCoords (coords) {\n            this.vertexCoords = coords;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.ShapeElement} element\n         * @returns {void}\n         */\n        setShapeElement (element) {\n            this.shapeEl = element;\n        }\n\n        /**\n        * @typedef {Element} module:imageMaps.VertexElement\n        */\n        /**\n         *\n         * @param {module:imageMaps.VertexElement} element\n         * @returns {void}\n         */\n        setVertexElement (element) {\n            this.vertexEl = element;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.VertexElements} elements\n         * @returns {void}\n         */\n        setVertexElements (elements) {\n            this.vertexEls = elements;\n        }\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.TypeHandler\n        * @property {string} type\n        * @property {function} handler\n        */\n        /**\n         * ImageMaps: 이미지맵 이벤트 할당.\n         * @param {Node|external:jQuery} element\n         * @param {module:imageMaps.TypeHandler[]} eventOptions\n         * @returns {void}\n         */\n        attachEvents (element, eventOptions) {\n            element = $(element);\n\n            eventOptions.forEach(({type, handler}) => {\n                element.on(\n                    type + '.' + areaClass,\n                    $.proxy(handler, this)\n                );\n            });\n        }\n\n        /**\n         * ImageMaps: 이미지맵 이벤트 해제.\n         * @param {external:jQuery} element\n         * @param {module:imageMaps.TypeHandler[]} eventOptions\n         * @returns {void}\n         */\n        detachEvents (element, eventOptions) {\n            element = $(element);\n\n            eventOptions.forEach(({type, handler}) => {\n                const eventType = type || '';\n                const eventHandler = handler\n                    ? $.proxy(handler, this)\n                    : '';\n\n                if (eventHandler) {\n                    element.off(eventType + '.' + areaClass, eventHandler);\n                } else {\n                    element.off(eventType + '.' + areaClass);\n                }\n            });\n        }\n    }\n    ImageMaps.getCoordsByRatio = getCoordsByRatio;\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {?(module:imageMaps.Coords)} coords\n     * @param {Url} linkUrl\n     * @returns {void}\n     */\n    function createMaps (coords, linkUrl) {\n        // 최초 맵영역을 만드는 순간에 map 엘리먼트를 만들고 하위에 area 엘리먼트 생성.\n        const uid = guid();\n        if (!this.container.attr('usemap')) {\n            this.mapEl = $(\n                '<map name=' + uid + '></map>'\n            ).insertAfter(this.container);\n            this.container.attr('usemap', '#' + uid);\n        } else {\n            const usemapName = this.container.attr('usemap').replace('#', '');\n            this.mapEl = $('body').find('map[name=' + usemapName + ']');\n        }\n\n        this.containerWidth = this.container.width();\n        this.containerHeight = this.container.height();\n\n        const imageWidth = this.containerWidth;\n        const imageHeight = this.containerHeight;\n        const centerX = imageWidth / 2;\n        const centerY = imageHeight / 2;\n\n        // 파라미터로 좌표값을 받으면 좌표에 해당하는 영역을 함께 그려준다.\n        const {shapeType} = this;\n\n        let shapeCoords = [];\n        let isDefaultTextCoords = false;\n\n        coords = convertStringToNumber(coords);\n        if (!(Array.isArray(coords))) {\n            // default 편집영역의 사이즈는 이미지의 0.1배로 계산. (내 맘대로..)\n            let defaultShapeX = imageWidth * 0.1,\n                defaultShapeY = imageHeight * 0.1;\n            const defaultRadius = (defaultShapeX >= defaultShapeY)\n                ? defaultShapeY\n                : defaultShapeX;\n            // invalid 좌표값이거나 배열이 아닌 타입일 경우는 디폴트 좌표로 그린다.\n            if (shapeType === SHAPE.RECT) {\n                shapeCoords = $.extend([], defaultShapeOptions.rect, [\n                    centerX - defaultShapeX,\n                    centerY - defaultShapeY,\n                    centerX + defaultShapeX,\n                    centerY + defaultShapeY\n                ]);\n            } else if (shapeType === SHAPE.CIRCLE) {\n                shapeCoords = $.extend([], defaultShapeOptions.circle, [\n                    centerX,\n                    centerY,\n                    defaultRadius\n                ]);\n            } else if (shapeType === SHAPE.ELLIPSE) {\n                shapeCoords = $.extend([], defaultShapeOptions.ellipse, [\n                    centerX,\n                    centerY,\n                    defaultRadius,\n                    defaultRadius\n                ]);\n            } else if (shapeType === SHAPE.IMAGE) {\n                const imageSize = getNaturalImageSize(this.shapeImageUrl);\n                defaultShapeX = imageSize.width / 2;\n                defaultShapeY = imageSize.height / 2;\n                shapeCoords = [\n                    centerX - defaultShapeX,\n                    centerY - defaultShapeY,\n                    centerX + defaultShapeX,\n                    centerY + defaultShapeY\n                ];\n            } else if (shapeType === SHAPE.POLY) {\n                // Todo\n            }\n        } else {\n            // 타입별로 정상적으로 좌표값을 받았다면 해당 좌표로 그린다.\n            // eslint-disable-next-line no-lonely-if\n            if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n                shapeCoords = $.extend([], defaultShapeOptions.rect, coords);\n            } else if (shapeType === SHAPE.CIRCLE) {\n                shapeCoords = $.extend([], defaultShapeOptions.circle, coords);\n            } else if (shapeType === SHAPE.ELLIPSE) {\n                shapeCoords = $.extend([], defaultShapeOptions.ellipse, coords);\n            } else if (shapeType === SHAPE.TEXT) {\n                if (!coords[0]) {\n                    coords[0] = centerX;\n                    isDefaultTextCoords = true;\n                }\n                if (!coords[1]) {\n                    coords[1] = centerY;\n                    isDefaultTextCoords = true;\n                }\n                if (!coords[2]) {\n                    coords[2] = 20;\n                }\n                shapeCoords = $.extend([], defaultShapeOptions.text, coords);\n            } else if (shapeType === SHAPE.POLY) {\n                // Todo\n            }\n        }\n\n        const index = this.mapEl.find('.' + shapeFaceClass).length;\n        let areaType = shapeType;\n        let shapeSecondaryOptions = {};\n\n        if (shapeType === SHAPE.TEXT || shapeType === SHAPE.IMAGE) {\n            areaType = SHAPE.RECT;\n\n            if (shapeType === SHAPE.TEXT) {\n                shapeSecondaryOptions = {text: this.shapeText};\n            } else {\n                shapeSecondaryOptions = {href: this.shapeImageUrl};\n            }\n        }\n\n        createOverlay.call(this, shapeCoords, uid, linkUrl, index);\n        this.setShapeCoords(shapeCoords);\n        this.updateShapeInfo(index, {\n            coords: shapeCoords,\n            type: shapeType,\n            url: linkUrl,\n            style: this.shapeStyle\n        }, shapeSecondaryOptions);\n\n        if (isDefaultTextCoords && this.isEditMode &&\n            shapeType === SHAPE.TEXT\n        ) {\n            adjustTextShape.call(this);\n        }\n\n        if (shapeType === SHAPE.ELLIPSE) {\n            areaType = SHAPE.CIRCLE;\n            shapeCoords = [\n                shapeCoords[0],\n                shapeCoords[1],\n                defaultShapeOptions.ellipse[2],\n                defaultShapeOptions.ellipse[2]\n            ];\n        }\n\n        createArea.call(this, areaType, shapeCoords, linkUrl, index);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {string} uid\n     * @param {Url} linkUrl\n     * @param {Integer} index\n     * @returns {void}\n     */\n    function createOverlay (shapeCoords, uid, linkUrl, index) {\n        const containerWidth = this.container.width(),\n            containerHeight = this.container.height();\n\n        if (typeof document.createElementNS !== 'undefined') {\n            let svgNativeEl = this.mapEl.find('svg').get(0);\n            let svgEl = $(svgNativeEl);\n            const {shapeType} = this;\n\n            if (!svgNativeEl) {\n                svgNativeEl = document.createElementNS(NS_SVG, 'svg');\n                svgEl = $(svgNativeEl);\n                this.svgEl = svgEl;\n\n                if (this.isEditMode) {\n                    this.attachEvents(svgEl, [{\n                        type: 'mousedown', handler: onMouseDown\n                    }]);\n                } else {\n                    this.attachEvents(this.mapEl, [{\n                        type: 'touchstart', handler: onTouchStart\n                    }, {\n                        type: 'click touchend', handler: onClickShapeFace\n                    }]);\n                }\n                this.attachEvents(window, [{\n                    type: 'resize', handler: onResize\n                }]);\n            }\n\n            // svgEl.get(0).setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n            // svg의 width, height는 DOM API로 처리해야 사이즈가 제대로 나옴.\n            svgNativeEl.setAttribute('width', containerWidth);\n            svgNativeEl.setAttribute('height', containerHeight);\n\n            // container의 부모에 대한 상대좌표에 따라 svg의 좌표값이 결정된다.\n            const containerPos = this.container.position();\n            svgEl.attr({\n                xmlns: NS_SVG,\n                'xmlns:xlink': NS_XLINK,\n                version: '1.1',\n                'data-Id': uid\n            }).css({\n                position: 'absolute',\n                zIndex: 1000,\n                overflow: 'hidden',\n                top: containerPos.top,\n                left: containerPos.left\n            });\n\n            const shapeGroupEl = createShape.call(\n                this,\n                shapeType,\n                shapeCoords,\n                linkUrl,\n                index\n            );\n            svgEl.append(shapeGroupEl);\n            this.mapEl.append(svgEl);\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {string} areaType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Url} linkUrl\n     * @param {string|Integer} index\n     * @returns {void}\n     */\n    function createArea (areaType, shapeCoords, linkUrl, index) {\n        $(\n            '<area shape=' + areaType +\n                ' coords=' + shapeCoords.join(',') +\n                ' href=' + (linkUrl || '#') +\n                ' data-index=' + index + ' ' +\n                (linkUrl ? 'target=\"_blank\"' : '') +\n                '>'\n        ).appendTo(this.mapEl);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Url} linkUrl\n     * @param {string|Integer} index\n     * @returns {void}\n     */\n    function createShape (shapeType, shapeCoords, linkUrl, index) {\n        if (shapeType === SHAPE.POLY) {\n            shapeType = SHAPE.POLYLINE;\n        }\n\n        const shapeEl = $(document.createElementNS(NS_SVG, shapeType));\n        const gEl = $(document.createElementNS(NS_SVG, 'g'));\n\n        drawShape.call(this, shapeCoords, shapeEl);\n\n        let cursor = 'default';\n        if (this.isEditMode) {\n            cursor = 'move';\n        } else if (linkUrl !== '') {\n            cursor = 'pointer';\n        }\n        this.setShapeStyle({cursor});\n        shapeEl.css(this.shapeStyle);\n\n        if (shapeType === SHAPE.TEXT) {\n            shapeEl.css({\n                'fill-opacity': '',\n                'stroke-opacity': ''\n            });\n        }\n\n        shapeEl.attr('data-index', index);\n        gEl.append(shapeEl);\n        this.setShapeElement(shapeEl);\n\n        if (this.isEditMode && shapeType !== 'text') {\n            const vertexEls = createVertex(shapeType, shapeCoords, index);\n            gEl.append(...vertexEls);\n            this.setVertexElements(vertexEls);\n        }\n\n        return gEl;\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.ShapeOptions\n    * @property {string} text\n    * @property {string} href\n    * @property {module:imageMaps.ShapeType} type\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {module:imageMaps.ShapeElement} [shapeEl]\n     * @param {module:imageMaps.ShapeOptions} [shapeOptions]\n     * @returns {void}\n     */\n    function drawShape (shapeCoords, shapeEl, shapeOptions) {\n        shapeEl = shapeEl || this.shapeEl;\n        const shapeType = shapeOptions ? shapeOptions.type : this.shapeType;\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            shapeEl.attr({\n                x: shapeCoords[0],\n                y: shapeCoords[1],\n                class: shapeFaceClass\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('width', shapeCoords[2] - shapeCoords[0]);\n            }\n            if (shapeCoords[3]) {\n                shapeEl.attr('height', shapeCoords[3] - shapeCoords[1]);\n            }\n            if (shapeType === SHAPE.IMAGE) {\n                // xlink 속성 설정 시에는 DOM api의 setAttributeNS를 사용해야 함.\n                // svg 전용 속성은 무조건 DOM api를 사용해야 함.\n                shapeEl.get(0).setAttributeNS(\n                    NS_XLINK,\n                    'href',\n                    (shapeOptions ? shapeOptions.href : this.shapeImageUrl)\n                );\n                // image 엘리먼트의 width, height를 고정 비율로 변경되는 걸 해제해주기 위한 속성 셋팅.\n                shapeEl.get(0).setAttribute('preserveAspectRatio', 'none');\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            shapeEl.attr({\n                cx: shapeCoords[0],\n                cy: shapeCoords[1],\n                class: shapeFaceClass\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('r', shapeCoords[2]);\n            }\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            shapeEl.attr({\n                cx: shapeCoords[0],\n                cy: shapeCoords[1],\n                class: shapeFaceClass\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('rx', shapeCoords[2]);\n            }\n            if (shapeCoords[3]) {\n                shapeEl.attr('ry', shapeCoords[3]);\n            }\n        } else if (shapeType === SHAPE.TEXT) {\n            shapeEl.attr({\n                x: shapeCoords[0],\n                y: shapeCoords[1],\n                'font-size': shapeCoords[2],\n                class: shapeFaceClass\n            });\n            shapeEl.text((shapeOptions && shapeOptions.text) || this.shapeText);\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @returns {void}\n     */\n    function adjustTextShape () {\n        const {shapeEl} = this;\n        const shapeSize = shapeEl.get(0).getBBox();\n        const centerX = shapeSize.width / 2;\n        const centerY = parseFloat(\n            shapeEl.attr('font-size')\n        ) * FONT_SIZE_RATIO / 2;\n        const bottomRightX = parseInt(shapeEl.attr('x'));\n        const bottomRightY = parseInt(shapeEl.attr('y'));\n        const resultX = bottomRightX - centerX;\n        const resultY = bottomRightY + centerY;\n\n        this.updateShapeInfo(shapeEl.data('index'), {\n            coords: [resultX, resultY, shapeEl.attr('font-size')]\n        });\n\n        shapeEl.attr({\n            x: resultX,\n            y: resultY\n        });\n    }\n\n    /**\n     * `SVGRect` element for each vertex coordinate\n    * @typedef {SVGRect[]} module:imageMaps.VertexElements One\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Integer} index\n     * @returns {module:imageMaps.VertexElements}\n     */\n    function createVertex (shapeType, shapeCoords, index) {\n        const vertexCoords = calculateVertexCoords(shapeType, shapeCoords);\n\n        const vertexTemp = vertexCoords.map(() => {\n            const vertexEl = $(document.createElementNS(NS_SVG, 'rect'));\n            vertexEl.attr('data-index', index).css({\n                fill: '#ffffff',\n                stroke: '#000000',\n                'stroke-width': 2\n            });\n            return vertexEl;\n        });\n\n        drawVertex(vertexCoords, vertexTemp, shapeType);\n\n        return vertexTemp;\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.VertexCoords\n    * @property {Float} x\n    * @property {Float} y\n    * @property {module:imageMaps.CursorType} type\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.VertexCoords} vertexCoords\n     * @param {module:imageMaps.VertexElements} vertexEls\n     * @param {module:imageMaps.ShapeType} shapeType Not currently in use\n     * @returns {void}\n     */\n    function drawVertex (vertexCoords, vertexEls, shapeType) {\n        vertexCoords.forEach((eachCoords, i) => {\n            $(vertexEls[i]).attr({\n                x: eachCoords.x - 3,\n                y: eachCoords.y - 3,\n                width: 7,\n                height: 7,\n                'data-direction': eachCoords.type,\n                class: shapeVertexClass\n            }).css('cursor', getCursor(eachCoords.type));\n        });\n    }\n\n    /**\n    * @typedef {module:imageMaps.Coords} module:imageMaps.ShapeCoords\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @returns {module:imageMaps.VertexCoords}\n     */\n    function calculateVertexCoords (shapeType, shapeCoords) {\n        let vertexArr = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            // 좌상, 좌하, 우상, 우하, 상, 하, 좌, 우 순\n            // 개별 vertex의 좌표값이므로 좌표의 순서는 크게 상관 없지만 참고로...\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1], type: 'nw'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[3], type: 'sw'\n            }, {\n                x: shapeCoords[2], y: shapeCoords[1], type: 'ne'\n            }, {\n                x: shapeCoords[2], y: shapeCoords[3], type: 'se'\n            }, {\n                x: (shapeCoords[2] - shapeCoords[0]) / 2 + shapeCoords[0],\n                y: shapeCoords[1], type: 'n'\n            }, {\n                x: (shapeCoords[2] - shapeCoords[0]) / 2 + shapeCoords[0],\n                y: shapeCoords[3],\n                type: 's'\n            }, {\n                x: shapeCoords[0],\n                y: (shapeCoords[3] - shapeCoords[1]) / 2 + shapeCoords[1],\n                type: 'w'\n            }, {\n                x: shapeCoords[2],\n                y: (shapeCoords[3] - shapeCoords[1]) / 2 + shapeCoords[1],\n                type: 'e'\n            }];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            // 상, 하, 좌, 우\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1] - shapeCoords[2], type: 'n'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[1] + shapeCoords[2], type: 's'\n            }, {\n                x: shapeCoords[0] - shapeCoords[2], y: shapeCoords[1], type: 'w'\n            }, {\n                x: shapeCoords[0] + shapeCoords[2], y: shapeCoords[1], type: 'e'\n            }];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            // 상, 하, 좌, 우\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1] - shapeCoords[3], type: 'n'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[1] + shapeCoords[3], type: 's'\n            }, {\n                x: shapeCoords[0] - shapeCoords[2], y: shapeCoords[1], type: 'w'\n            }, {\n                x: shapeCoords[0] + shapeCoords[2], y: shapeCoords[1], type: 'e'\n            }];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return vertexArr;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Element} areaEl\n     * @param {module:imageMaps.ShapeType} [shapeType]\n     * @returns {void}\n     */\n    function drawArea (shapeCoords, areaEl, shapeType) {\n        const shapeEl = this.svgEl.find(\n            '.' + shapeFaceClass + '[data-index=\"' + areaEl.data('index') + '\"]'\n        );\n        shapeType = shapeType || this.shapeType;\n\n        if (shapeType === SHAPE.TEXT) {\n            shapeCoords = convertTextToRectCoords(shapeEl);\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            shapeCoords = [\n                shapeCoords[0],\n                shapeCoords[1],\n                defaultShapeOptions.ellipse[2]\n            ];\n        }\n        areaEl.attr('coords', shapeCoords.join(','));\n    }\n\n    /**\n    * @typedef {\"col\"|\"row\"|Direction|\"ew\"|\"ns\"|\"nesw\"|\"nwse\"}\n    *   module:imageMaps.CursorType\n    */\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.CursorType} type\n     *     CSS cursor resize type\n     * @returns {string}\n     */\n    function getCursor (type) {\n        return type + '-resize';\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `touchstart` event\n     * @returns {void}\n     */\n    function onTouchStart (e) {\n        const touchCoords = e.originalEvent.touches[0];\n        this.touchStartCoords.x = touchCoords.pageX;\n        this.touchStartCoords.y = touchCoords.pageY;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `click touchend` event\n     * @returns {void}\n     */\n    function onClickShapeFace (e) {\n        // IE8이 이외의 브라우저는 아래 계산 로직을 타지 않아도 된다.\n        // IE8은 area 엘리먼트 클릭 시 href 속성의 url로 이동.\n        let targetAreaEl = $(e.currentTarget);\n        if (e.currentTarget.tagName.toLowerCase() !== 'area') {\n            e.preventDefault();\n            if ((this.dragInfo.face.x && this.dragInfo.face.x !== e.pageX) ||\n                (this.dragInfo.face.y && this.dragInfo.face.y !== e.pageY) ||\n                e.target.tagName.toLowerCase() === 'svg' ||\n                (e.type === 'touchend' &&\n                    e.originalEvent.changedTouches[0].pageX !==\n                      this.touchStartCoords.x &&\n                    e.originalEvent.changedTouches[0].pageY !==\n                      this.touchStartCoords.y)\n            ) {\n                return;\n            }\n\n            // 클릭하거나 마우스엔터, 마우스다운 된 shape를 현재 타겟으로 저장.\n            // 타겟이 되는 shape의 좌표 정보를 가지고 모든 로직이 수행되도록 한다.\n            const targetEl = $(e.target);\n            const index = targetEl.attr('data-index');\n            targetAreaEl = this.mapEl.find('area[data-index=\"' + index + '\"]');\n            const url = targetAreaEl.attr('href');\n\n            (url !== '#') && window.open(targetAreaEl.attr('href'));\n        }\n\n        this.options.onClick.call(this, e, targetAreaEl.attr('href'));\n    }\n\n    // drag & drop\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `mousedown` event\n     * @returns {void}\n     */\n    function onMouseDown (e) {\n        e.preventDefault();\n\n        if (e.target.tagName.toLowerCase() === 'svg') {\n            return;\n        }\n\n        const targetEl = $(e.target);\n        const index = targetEl.attr('data-index');\n        const shapeInfo = this.getShapeInfo(index);\n        const groupEl = targetEl.parent();\n        const shapeEl = groupEl.find(':first-child');\n        let coords = [];\n        let shapeType = shapeEl.get(0).tagName.toLowerCase();\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const targetX = parseInt(shapeEl.attr('x'));\n            const targetY = parseInt(shapeEl.attr('y'));\n            coords = [\n                targetX,\n                targetY,\n                targetX + parseInt(shapeEl.attr('width')),\n                targetY + parseInt(shapeEl.attr('height'))\n            ];\n            if (shapeType === SHAPE.IMAGE) {\n                this.setImageShape(shapeEl.attr('href'));\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            const targetX = parseInt(shapeEl.attr('cx'));\n            const targetY = parseInt(shapeEl.attr('cy'));\n            coords = [targetX, targetY, parseInt(shapeEl.attr('r'))];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            const targetX = parseInt(shapeEl.attr('cx'));\n            const targetY = parseInt(shapeEl.attr('cy'));\n            coords = [\n                targetX, targetY,\n                parseInt(shapeEl.attr('rx')),\n                parseInt(shapeEl.attr('ry'))\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            const targetX = parseFloat(shapeEl.attr('x'));\n            const targetY = parseFloat(shapeEl.attr('y'));\n            const fontSize = parseFloat(shapeEl.attr('font-size'));\n            coords = [targetX, targetY, fontSize];\n            this.shapeText = shapeEl.text();\n        } else if (shapeType === SHAPE.POLYGON) {\n            shapeType = SHAPE.POLY;\n        }\n\n        this.setShapeType(shapeType);\n        this.setShapeElement(shapeEl);\n        this.setShapeCoords(coords);\n\n        if (shapeType !== SHAPE.TEXT) {\n            shapeEl.attr('data-fill', shapeEl.css('fill'));\n            shapeEl.css('fill', '#ffffff');\n\n            this.setVertexCoords(calculateVertexCoords(shapeType, coords));\n\n            const vertexTemp = [];\n            const vertexEls = this.mapEl.find(\n                '.' + shapeVertexClass + '[data-index=\"' + index + '\"]'\n            );\n            vertexEls.each(function () {\n                vertexTemp.push($(this));\n            });\n            this.setVertexElements(vertexTemp);\n        }\n\n        if (targetEl.is('.' + shapeFaceClass)) {\n            this.grabType = 'face';\n            declareShape.call(this, targetEl, e.pageX, e.pageY);\n        } else if (targetEl.is('.' + shapeVertexClass)) {\n            this.grabType = 'vertex';\n            declareVertex.call(this, targetEl, index);\n        }\n\n        this.attachEvents(this.mapEl.parent(), [{\n            type: 'mouseup', handler: onMouseUp\n        }, {\n            type: 'mousemove', handler: onMouseMove\n        }]);\n\n        this.options.onSelect.call(this, e, shapeInfo);\n        this.options.onMouseDown.call(this, e, shapeType, coords);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `mouseup` event\n     * @returns {void}\n     */\n    function onMouseUp (e) {\n        const targetEl = $(e.target);\n        const {shapeEl} = this;\n\n        shapeEl.css('fill', shapeEl.attr('data-fill'));\n        targetEl.attr('data-movable', false);\n\n        const updatedCoords = determineShape.call(this);\n        this.setShapeCoords(updatedCoords);\n        this.updateShapeInfo(shapeEl.data('index'), {coords: updatedCoords});\n\n        this.detachEvents(this.mapEl.parent(), [{\n            type: 'mouseup', handler: onMouseUp\n        }, {\n            type: 'mousemove', handler: onMouseMove\n        }]);\n\n        this.options.onMouseUp.call(this, e, this.shapeType, updatedCoords);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `mousemove` event\n     * @returns {void}\n     */\n    function onMouseMove (e) {\n        const targetEl = $(e.target);\n        const [x, y] = this.shapeCoords;\n        const {grabType, shapeType} = this;\n        let coords = {};\n\n        // 좌표 계산 시 e.offsetX, offsetY값은 이벤트 발생 대상(e.currentTarget)\n        //   기준 좌표 값이므로\n        // 이벤트 발생 도중(특히 mousemove) 겹치는 이벤트 타겟이 생기면 해당 타겟 기준\n        //    좌표로 변경되어 좌표가 튀는 현상 발생.\n        // 그러므로 브라우저에서 drag & drop 구현 시 웬만하면 브라우저의 절대 좌표값인\n        //    e.pageX, pageY를 사용하도록 한다.\n        if (grabType === 'face' || grabType === 'vertex') {\n            if (grabType === 'face') {\n                const movedX = x + e.pageX;\n                const movedY = y + e.pageY;\n\n                coords = getMovedShapeCoords.call(\n                    this,\n                    movedX - this.dragInfo.face.x,\n                    movedY - this.dragInfo.face.y\n                );\n            } else if (grabType === 'vertex') {\n                coords = getMovedVertexCoords.call(\n                    this,\n                    e.pageX - this.svgEl.offset().left,\n                    e.pageY - this.svgEl.offset().top\n                );\n            }\n            if (!coords) {\n                return;\n            }\n\n            if (shapeType !== SHAPE.TEXT) {\n                this.setVertexCoords(coords.vertexCoords);\n                drawVertex(coords.vertexCoords, this.vertexEls, this.shapeType);\n            }\n            const index = parseInt(coords.grabEl.attr('data-index'));\n            drawShape.call(\n                this,\n                coords.movedCoords,\n                this.svgEl.find(\n                    '.' + shapeFaceClass + '[data-index=\"' + index + '\"]'\n                )\n            );\n            drawArea.call(\n                this,\n                coords.movedCoords,\n                this.mapEl.find('area[data-index=\"' + index + '\"]')\n            );\n\n            // svg 내 엘리먼트들은 z-index 영향을 받지 않고 document 순서에 영향을 받는다.\n            // 그래서 drag 시 다른 요소들보다 최상위에 두려면 엘리먼트 순서를 부모의 가장 하위에 두어야 한다.\n            // mousedown에서 이 로직을 넣을 경우,\n            // 외부에서 click 이벤트를 할당했을 때 mousedown 핸들러에서 dom 우선순위 조정하는 과정에서\n            //    click 이벤트가 해제되는 이슈로 mousemove 안에 둠.\n            if (\n                (\n                    targetEl.is('.' + shapeFaceClass) ||\n                    targetEl.is('.' + shapeVertexClass)\n                ) &&\n                (Math.abs(this.dragInfo.face.x - e.pageX) <= 1 ||\n                    Math.abs(this.dragInfo.face.y - e.pageY) <= 1)\n            ) {\n                this.svgEl.append(targetEl.parent());\n            }\n\n            this.options.onMouseMove.call(\n                this,\n                e,\n                shapeType,\n                coords.movedCoords\n            );\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `resize` event\n     * @returns {void}\n     */\n    function onResize (e) {\n        const containerWidth = this.container.width();\n        const containerHeight = this.container.height();\n\n        if (this.containerWidth !== containerWidth ||\n            this.containerHeight !== containerHeight\n        ) {\n            redraw.call(this, containerWidth, containerHeight);\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float[]} percentages\n     * @returns {void}\n     */\n    function zoom (percentages) {\n        const widthPercentage = percentages[0];\n        const heightPercentage = (percentages.length < 2)\n            ? widthPercentage\n            : percentages[1];\n        const containerWidth = widthPercentage * 0.01 * this.container.width();\n        const containerHeight = heightPercentage * 0.01 *\n            this.container.height();\n\n        this.container.css({\n            width: containerWidth + 'px',\n            height: containerHeight + 'px'\n        });\n\n        setTimeout(() => {\n            if (this.svgEl && this.svgEl.length > 0) {\n                redraw.call(this, containerWidth, containerHeight);\n            }\n        });\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} containerWidth\n     * @param {Float} containerHeight\n     * @returns {void}\n     */\n    function redraw (containerWidth, containerHeight) {\n        const {allShapeInfo} = this;\n        const widthRatio = containerWidth / this.containerWidth;\n        const heightRatio = containerHeight / this.containerHeight;\n        const containerPos = this.container.position();\n\n        this.svgEl.get(0).setAttribute('width', containerWidth);\n        this.svgEl.get(0).setAttribute('height', containerHeight);\n        this.svgEl.css({\n            top: containerPos.top,\n            left: containerPos.left\n        });\n\n        $.each(allShapeInfo, (index, item) => {\n            item.coords = getCoordsByRatio(\n                item.coords, item.type, widthRatio, heightRatio\n            );\n\n            drawVertex(\n                calculateVertexCoords(item.type, item.coords),\n                this.svgEl.find(\n                    '.' + shapeVertexClass + '[data-index=\"' + item.index + '\"]'\n                ),\n                item.type\n            );\n            drawShape.call(\n                this,\n                item.coords,\n                this.svgEl.find(\n                    '.' + shapeFaceClass + '[data-index=\"' + item.index + '\"]'\n                ),\n                item\n            );\n            drawArea.call(\n                this,\n                item.coords,\n                this.mapEl.find('area[data-index=\"' + item.index + '\"]'),\n                item.type\n            );\n        });\n\n        this.containerWidth = containerWidth;\n        this.containerHeight = containerHeight;\n    }\n\n    /**\n    * @typedef {Element} module:imageMaps.ShapeElement\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeElement} shapeEl\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {void}\n     */\n    function declareShape (shapeEl, x, y) {\n        this.dragInfo.face.x = x;\n        this.dragInfo.face.y = y;\n\n        shapeEl.attr('data-movable', true);\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.MovedCoords\n    * @property {module:imageMaps.Coords} movedCoords,\n    * @property {module:imageMaps.VertexCoords} vertexCoords,\n    * @property {module:imageMaps.ShapeElement} grabEl\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {module:imageMaps.MovedCoords|void}\n     */\n    function getMovedShapeCoords (x, y) {\n        const {shapeEl} = this;\n        if (shapeEl.attr('data-movable') === 'false') {\n            return undefined;\n        }\n\n        let movedCoords = [];\n        let vertexCoords = [];\n        const {shapeType} = this;\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const width = parseInt(shapeEl.attr('width'));\n            const height = parseInt(shapeEl.attr('height'));\n            const movedBottomRightX = x + width;\n            const movedBottomRightY = y + height;\n\n            movedCoords = [x, y, movedBottomRightX, movedBottomRightY];\n            vertexCoords = calculateVertexCoords(SHAPE.RECT, movedCoords);\n        } else if (shapeType === SHAPE.CIRCLE) {\n            movedCoords = [x, y, parseInt(shapeEl.attr('r'))];\n            vertexCoords = calculateVertexCoords(SHAPE.CIRCLE, movedCoords);\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            movedCoords = [\n                x,\n                y,\n                parseInt(shapeEl.attr('rx')),\n                parseInt(shapeEl.attr('ry'))\n            ];\n            vertexCoords = calculateVertexCoords(SHAPE.ELLIPSE, movedCoords);\n        } else if (shapeType === SHAPE.TEXT) {\n            movedCoords = [x, y];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return {\n            movedCoords,\n            vertexCoords,\n            grabEl: shapeEl\n        };\n    }\n\n    /**\n    * @typedef {GenericArray} module:imageMaps.Coords\n    * @property {Float} 0\n    * @property {Float} 1\n    * @property {Float} 2\n    * @property {Float} 3\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @returns {module:imageMaps.Coords}\n     */\n    function determineShape () {\n        const {shapeEl, shapeType} = this;\n        let updatedCoords = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const x = parseInt(shapeEl.attr('x'));\n            const y = parseInt(shapeEl.attr('y'));\n            updatedCoords = [\n                x,\n                y,\n                x + parseInt(shapeEl.attr('width')),\n                y + parseInt(shapeEl.attr('height'))\n            ];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            updatedCoords = [\n                parseInt(shapeEl.attr('cx')),\n                parseInt(shapeEl.attr('cy')),\n                parseInt(shapeEl.attr('r'))\n            ];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            updatedCoords = [\n                parseInt(shapeEl.attr('cx')),\n                parseInt(shapeEl.attr('cy')),\n                parseInt(shapeEl.attr('rx')),\n                parseInt(shapeEl.attr('ry'))\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            updatedCoords = [\n                parseInt(shapeEl.attr('x')),\n                parseInt(shapeEl.attr('y'))\n            ];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return updatedCoords;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {external:jQuery} vertexEl\n     * @param {Integer} index Not currently in use\n     * @returns {void}\n     */\n    function declareVertex (vertexEl, index) {\n        this.setVertexElement(vertexEl);\n\n        let vertexIndex = 0;\n        this.vertexEls.forEach((item, idx) => {\n            if (vertexEl.get(0) === item.get(0)) {\n                vertexIndex = idx;\n            }\n        });\n\n        const coords = this.vertexCoords[vertexIndex];\n        this.dragInfo.vertex.x = coords.x;\n        this.dragInfo.vertex.y = coords.y;\n\n        vertexEl.attr('data-movable', true);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {module:imageMaps.MovedVertexCoords|void}\n     */\n    function getMovedVertexCoords (x, y) {\n        if (this.vertexEl.attr('data-movable') === 'false') {\n            return undefined;\n        }\n\n        let movedCoords = [];\n        let vertexCoords = [];\n\n        const {shapeType} = this;\n        const direction = this.vertexEl.attr('data-direction');\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            switch (direction) {\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            // 좌상\n            case 'nw':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [x, y, this.shapeCoords[2], this.shapeCoords[3]],\n                    direction\n                );\n                break;\n            // 좌하\n            case 'sw':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [x, this.shapeCoords[1], this.shapeCoords[2], y],\n                    direction\n                );\n                break;\n            // 우상\n            case 'ne':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [this.shapeCoords[0], y, x, this.shapeCoords[3]],\n                    direction\n                );\n                break;\n            // 우하\n            case 'se':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [this.shapeCoords[0], this.shapeCoords[1], x, y],\n                    direction\n                );\n                break;\n            // 상\n            case 'n':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        y,\n                        this.shapeCoords[2],\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            // 하\n            case 's':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        this.shapeCoords[1],\n                        this.shapeCoords[2],\n                        y\n                    ],\n                    direction\n                );\n                break;\n            // 좌\n            case 'w':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        x,\n                        this.shapeCoords[1],\n                        this.shapeCoords[2],\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            // 우\n            case 'e':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        this.shapeCoords[1],\n                        x,\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            switch (direction) {\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            case 'n':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(\n                        this,\n                        this.shapeCoords[1] - y\n                    )\n                ];\n                break;\n            case 's':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, y - this.shapeCoords[1])\n                ];\n                break;\n            case 'w':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[0] - x)\n                ];\n                break;\n            case 'e':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, x - this.shapeCoords[0])\n                ];\n                break;\n            }\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            switch (direction) {\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            case 'n':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    this.shapeCoords[2],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[1] - y)\n                ];\n                break;\n            case 's':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    this.shapeCoords[2],\n                    getValidCoordsForCircle.call(this, y - this.shapeCoords[1])\n                ];\n                break;\n            case 'w':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[0] - x),\n                    this.shapeCoords[3]\n                ];\n                break;\n            case 'e':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, x - this.shapeCoords[0]),\n                    this.shapeCoords[3]\n                ];\n                break;\n            }\n        } else if (shapeType === SHAPE.POLY) {\n            // polygon의 경우, 드래그 되는 좌표에 따라 이벤트 대상 vertex의 x, y 좌표가 자유롭게 변경.\n        }\n\n        vertexCoords = calculateVertexCoords(shapeType, movedCoords);\n\n        return {\n            movedCoords,\n            vertexCoords,\n            grabEl: this.vertexEl\n        };\n    }\n\n    /**\n    * @typedef {\"se\"|\"sw\"|\"ne\"|\"nw\"|\"w\"|\"s\"|\"n\"|\"e\"} module:imageMaps.Direction\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.RectCoords} coords\n     * @param {module:imageMaps.Direction} direction\n     * @returns {module:imageMaps.RectCoords}\n     */\n    function getValidCoordsForRect (coords, direction) {\n        let [topLeftX, topLeftY, bottomRightX, bottomRightY] = coords;\n\n        if (bottomRightX - topLeftX <= this.shapeLimitCoords.x) {\n            if (direction === 'se' || direction === 'ne' || direction === 'e') {\n                bottomRightX = topLeftX + this.shapeLimitCoords.x;\n            }\n            if (direction === 'nw' || direction === 'sw' || direction === 'w') {\n                topLeftX = bottomRightX - this.shapeLimitCoords.x;\n            }\n        }\n\n        if (bottomRightY - topLeftY <= this.shapeLimitCoords.y) {\n            if (direction === 'se' || direction === 'sw' || direction === 's') {\n                bottomRightY = topLeftY + this.shapeLimitCoords.y;\n            }\n            if (direction === 'nw' || direction === 'ne' || direction === 'n') {\n                topLeftY = bottomRightY - this.shapeLimitCoords.y;\n            }\n        }\n\n        return [topLeftX, topLeftY, bottomRightX, bottomRightY];\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} coordsDiff\n     * @returns {Float}\n     */\n    function getValidCoordsForCircle (coordsDiff) {\n        let radius;\n\n        if (coordsDiff <= this.shapeLimitCoords.radius) {\n            ({radius} = this.shapeLimitCoords);\n        } else {\n            radius = coordsDiff;\n        }\n\n        return radius;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.Coords} coords\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {Float} widthRatio\n     * @param {Float} heightRatio\n     * @returns {module:imageMaps.Coords}\n     */\n    function getCoordsByRatio (coords, shapeType, widthRatio, heightRatio) {\n        let adjustCoords = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE ||\n            shapeType === SHAPE.ELLIPSE\n        ) {\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * widthRatio,\n                coords[3] * heightRatio\n            ];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            let radiusRatio;\n\n            if (widthRatio >= heightRatio) {\n                radiusRatio = heightRatio;\n            } else {\n                radiusRatio = widthRatio;\n            }\n\n            if (widthRatio === 1) {\n                radiusRatio = heightRatio;\n            }\n\n            if (heightRatio === 1) {\n                radiusRatio = widthRatio;\n            }\n\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * radiusRatio\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * widthRatio\n            ];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return adjustCoords;\n    }\n\n    /**\n    * @typedef {GenericArray} module:imageMaps.RectCoords\n    * @property {Float} 0\n    * @property {Float} 1\n    * @property {Float} 2\n    * @property {Float} 3\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.ShapeElement} shapeEl\n     * @returns {module:imageMaps.RectCoords}\n     */\n    function convertTextToRectCoords (shapeEl) {\n        const bottomLeftX = parseFloat(shapeEl.attr('x'));\n        const bottomLeftY = parseFloat(shapeEl.attr('y'));\n        const shapeSize = shapeEl.get(0).getBBox();\n        const {width} = shapeSize;\n        const height = parseFloat(shapeEl.attr('font-size')) *\n            FONT_SIZE_RATIO / 2;\n\n        return [\n            bottomLeftX,\n            bottomLeftY - height,\n            bottomLeftX + width,\n            bottomLeftY\n        ];\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {string} [coords]\n     * @returns {?(Float[])}\n     */\n    function convertStringToNumber (coords) {\n        if (!coords) {\n            return null;\n        }\n\n        return [...coords].map((ch) => parseFloat(ch));\n    }\n\n    //   UTIL FUNCTIONS\n\n    /**\n     * GUID: img의 usemap 속성, map의 name 속성을 unique id로 생성.\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @see https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n     * @returns {string}\n     */\n    function guid () {\n        /**\n         * @memberof module:imageMaps.jqueryImageMaps~guid.\n         * @static\n         * @returns {string}\n         */\n        function s4 () {\n            return Math.floor(\n                (1 + Math.random()) * 0x10000\n            ).toString(16).substring(1);\n        }\n        return s4() + s4() + '-' + s4() + '-' + s4() +\n            '-' + s4() + '-' + s4() + s4() + s4();\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.Dimensions\n    * @property {Float} width\n    * @property {Float} height\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {HTMLImageElement|string} imageElOrUrl\n     * @todo If this is to handle an image element, other contexts which use\n     *    the passed in URL should also\n     * @returns {module:imageMaps.Dimensions}\n     */\n    function getNaturalImageSize (imageElOrUrl) {\n        const imageObj = new Image();\n        if (('naturalWidth' in imageObj) && typeof imageElOrUrl !== 'string') {\n            return {\n                width: imageElOrUrl.naturalWidth,\n                height: imageElOrUrl.naturalHeight\n            };\n        }\n        if (typeof imageElOrUrl === 'string') {\n            imageElOrUrl = {src: imageElOrUrl};\n        }\n        imageObj.src = imageElOrUrl.src;\n        return {\n            width: imageObj.width,\n            height: imageObj.height\n        };\n    }\n\n    $.fn.extend({\n        /**\n         * @function external:\"jQuery.fn\".createMaps\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @returns {external:jQuery}\n         */\n        createMaps (coords, linkUrl) {\n            this.data('image_maps_inst').createMaps(coords, linkUrl);\n            return this;\n        },\n\n        /**\n         *\n         * @param {external:jQuery} targetEl\n         * @returns {external:jQuery}\n         */\n        copyImageMapsTo (targetEl) {\n            $.imageMaps.copyImageMaps({\n                shapes: this.getAllShapes(),\n                width: this.width(),\n                height: this.height()\n            }, targetEl);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".addShape\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @param {module:imageMaps.ShapeType} shapeType\n         * @returns {external:jQuery}\n         */\n        addShape (coords, linkUrl, shapeType) {\n            this.data('image_maps_inst').addShape(coords, linkUrl, shapeType);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".removeShape\n         * @param {Integer} [index]\n         * @returns {external:jQuery}\n         */\n        removeShape (index) {\n            this.data('image_maps_inst').removeShape(index);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".removeAllShapes\n         * @returns {external:jQuery}\n         */\n        removeAllShapes () {\n            this.data('image_maps_inst').removeAllShapes();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".destroy\n         * @returns {external:jQuery}\n         */\n        destroy () {\n            const imageMapsObj = this.data('image_maps_inst');\n            if (!imageMapsObj) {\n                return;\n            }\n\n            imageMapsObj.removeImageMaps();\n            this.data('image_maps_inst', null);\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setShapeStyle\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {external:jQuery}\n         */\n        setShapeStyle (styleOptions) {\n            this.data('image_maps_inst').setShapeStyle(styleOptions);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setUrl\n         * @param {Url} linkUrl\n         * @param {Integer} index\n         * @returns {external:jQuery}\n         */\n        setUrl (linkUrl, index) {\n            this.data('image_maps_inst').setUrl(linkUrl, index);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setTextShape\n         * @param {string} text\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {external:jQuery}\n         */\n        setTextShape (text, styleOptions) {\n            this.data('image_maps_inst').setTextShape(text, styleOptions);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setImageShape\n         * @param {Url} imageUrl\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {external:jQuery}\n         */\n        setImageShape (imageUrl, styleOptions) {\n            this.data('image_maps_inst').setImageShape(imageUrl, styleOptions);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".enableClick\n         * @returns {void}\n         */\n        enableClick () {\n            this.data('image_maps_inst').enableClick();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".disableClick\n         * @returns {void}\n         */\n        disableClick () {\n            this.data('image_maps_inst').disableClick();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".getAllShapes\n         * @returns {module:imageMaps.AllShapeInfo}\n         */\n        getAllShapes () {\n            return this.data('image_maps_inst').getAllShapesInfo();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".getCoordsByRatio\n         * @param {module:imageMaps.Coords} coords\n         * @param {module:imageMaps.ShapeType} shapeType\n         * @param {Float} widthRatio\n         * @param {Float} heightRatio\n         * @returns {module:imageMaps.Coords}\n         */\n        getCoordsByRatio (coords, shapeType, widthRatio, heightRatio) {\n            return ImageMaps.getCoordsByRatio(\n                coords, shapeType, widthRatio, heightRatio\n            );\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".zoom\n         * @param {Float[]} percentages\n         * @returns {void}\n         */\n        zoom (percentages) {\n            this.data('image_maps_inst').zoom(percentages);\n        }\n    });\n\n    $.imageMaps = {\n        /**\n        * @typedef {PlainObject} module:imageMaps.SourceInfo\n        * @property {module:imageMaps.AllShapeInfo} shapes\n        * @property {Float} width\n        * @property {Float} height\n        */\n        /**\n         * @param {module:imageMaps.SourceInfo} sourceInfo\n         * @param {external:jQuery} targetEl\n         * @returns {void}\n         */\n        copyImageMaps ({shapes, width, height}, targetEl) {\n            targetEl.removeAllShapes();\n            $.each(shapes, (index, item) => {\n                targetEl.setShapeStyle(item.style);\n                if (item.href) {\n                    targetEl.setImageShape(item.href);\n                }\n                if (item.text) {\n                    targetEl.setTextShape(item.text);\n                }\n\n                const widthRatio = width;\n                const heightRatio = height;\n                const newCoords = getCoordsByRatio(\n                    item.coords,\n                    item.type,\n                    targetEl.width() / widthRatio,\n                    targetEl.height() / heightRatio\n                );\n                targetEl.addShape(newCoords, item.url, item.type);\n            });\n        }\n    };\n\n    /**\n     * @function external:\"jQuery.fn\".imageMaps\n     * @this external:jQuery\n     * @param {module:imageMaps.ImageMapOptions} [options]\n     * @throws {Error}\n     * @returns {module:imageMaps.ImageMaps|void}\n     */\n    $.fn.imageMaps = function (options) {\n        if (this.length === 1) {\n            if (!this.data('image_maps_inst')) {\n                const imageMapsInst = new ImageMaps(this, options);\n                this.data('image_maps_inst', imageMapsInst);\n                return imageMapsInst;\n            }\n            return this.data('image_maps_inst');\n        }\n        if (this.length > 1) {\n            throw new Error('imageMaps instance has already been created.');\n        }\n        return undefined;\n    };\n    return $;\n}\n\nexport default jqueryImageMaps;\n"],"names":["shapeFaceClass","shapeVertexClass","areaClass","SHAPE","RECT","CIRCLE","ELLIPSE","TEXT","IMAGE","POLY","POLYLINE","POLYGON","defaults","isEditMode","shape","shapeText","shapeStyle","fill","stroke","onClick","e","targetAreaHref","onMouseDown","shapeType","coords","onMouseMove","movedCoords","onMouseUp","updatedCoords","onSelect","shapeInfo","defaultShapeOptions","rect","circle","ellipse","text","FONT_SIZE_RATIO","NS_SVG","NS_XLINK","$","ImageMaps","container","options","mapEl","svgEl","extend","this","shapeImageUrl","shapeCoords","vertexCoords","grabType","containerWidth","containerHeight","touchStartCoords","x","y","dragInfo","face","vertex","shapeLimitCoords","radius","allShapeInfo","linkUrl","imageWidth","width","isNaN","one","proxy","createMaps","call","styleOptions","index","setShapeStyle","imageUrl","setShapeType","shapeEl","data","areaEl","find","detachEvents","type","parent","remove","removeShapeInfo","each","i","_this","removeShape","removeAllShapes","shapeOptions","shapeSecondaryOptions","percentages","widthPercentage","heightPercentage","length","height","css","setTimeout","_this4","redraw","attachEvents","handler","onTouchStart","onClickShapeFace","element","vertexEl","elements","vertexEls","eventOptions","forEach","on","_this2","eventType","eventHandler","_this3","off","uid","s4","Math","floor","random","toString","substring","guid","attr","usemapName","replace","insertAfter","imageElOrUrl","imageObj","imageHeight","centerX","centerY","isDefaultTextCoords","_toConsumableArray","map","ch","parseFloat","convertStringToNumber","Array","isArray","defaultShapeX","defaultShapeY","defaultRadius","imageSize","Image","naturalWidth","naturalHeight","src","areaType","href","document","createElementNS","svgNativeEl","get","window","onResize","setAttribute","containerPos","position","xmlns","version","zIndex","overflow","top","left","shapeGroupEl","gEl","drawShape","cursor","append","setShapeElement","calculateVertexCoords","vertexTemp","drawVertex","createVertex","setVertexElements","setShapeCoords","updateShapeInfo","url","style","getBBox","bottomRightX","parseInt","bottomRightY","resultX","resultY","join","appendTo","setAttributeNS","cx","cy","eachCoords","vertexArr","drawArea","bottomLeftX","bottomLeftY","convertTextToRectCoords","touchCoords","originalEvent","touches","pageX","pageY","targetAreaEl","currentTarget","tagName","toLowerCase","preventDefault","target","changedTouches","open","targetEl","getShapeInfo","targetX","targetY","setImageShape","setVertexCoords","push","is","setVertexElement","vertexIndex","item","idx","movedX","movedY","movedBottomRightX","movedBottomRightY","grabEl","direction","console","warn","getValidCoordsForRect","getValidCoordsForCircle","offset","abs","widthRatio","heightRatio","getCoordsByRatio","_this5","topLeftX","topLeftY","coordsDiff","adjustCoords","radiusRatio","fn","copyImageMapsTo","imageMaps","copyImageMaps","shapes","getAllShapes","addShape","destroy","imageMapsObj","removeImageMaps","setUrl","setTextShape","enableClick","disableClick","getAllShapesInfo","zoom","newCoords","imageMapsInst","Error"],"mappings":"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"}